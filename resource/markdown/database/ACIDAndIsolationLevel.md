<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">数据库事务是什么？</h3>

**数据库事务**(Database Transaction) ，是指作为 **单个逻辑工作单元** 执行的 *一系列操作*，要么完全地执行，要么完全地不执行。



<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">一、事务的四大特性</h3>

#### :new_moon: 原子性（Atomicity）

> **原子性** 是指事务包含的所有 *一系列操作*  要么全部成功提交，要么全部失败回滚。它也是数据库事务最最本质的特性。
>
> 比如一个事务包含两个更新操作A和B，A操作更新成功，而B操作更新失败，则A操作会被回滚。绝不会出现一个成功、一个失败的场景，否则这不是一个事务。



#### :four_leaf_clover:一致性（Consistency ）

> **一致性** 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。这里有个容易混淆点，容易和数据一致性混淆。这里更多的强调的是单机下的事务一致性，必须是一个事务内部。

保证数据库一致性的主要机制层面：数据库机制层面、业务层面。



#### :umbrella:隔离性（Isolation ）

每个事务都有各自的资源单位，事务与事务之间是互相隔离的、不可见的，而事务的结果是对其他事务可见的。

一个数据库系统中存在多个事务，每个事务中的各个子操作是对其他事务不可见的，在提交后的结果是对其他事务可见的。可以理解为资源粒子度的划分与隔离。



#### :memo:持久性（Durability ）

持久性确保的是一旦提交了事务，即使出现系统故障，该事务的更新也不会丢失。我们可以宽泛的认为，将数据持久化到磁盘。



<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">三、事务的四种隔离级别</h3>

> 隔离级别由低到高分别为



#### 读未提交（READ_UNCOMMITTED） 

> 就是一个事务A读取另一个事务B *未提交* 的数据。（如果如果事务B出现 **回滚**，那么事务A就会出现 ~~*脏读*~~:x: 的问题）。



#### 读已提交（READ_COMMITTED）

>  一个事务A读取另一个事务B *已提交* 的数据，那么这样可以解决 ~~`脏读`~~ 的问题。保证读取的数据 **已提交**:white_check_mark: 而不能被 ~~回滚~~:back:。在事务B提交前的 **update**，事务A是读取不到的。只有事务B提交后，事务A才能读取到事务B的 `update改动`。出现的问题是  *一个事务范围内两个相同的查询却返回了不同的数据*，那么这就是`不可重复读`。



#### 可重复读（REPETABLE_READ）

> 事务开启时，不再允许其他事务 ~~修改(update)~~ 数据。这样就可以无限制的读取没有被 ~~修改(update)~~ 的数据了。出现的问题是，当有 **并行插入(insert)** 操作时就会出现 **幻读**。



#### 可串行化（SERIALIZABLE）

> 在可串行化的隔离级别下，将事务  **串行化** 顺序执行。那么事务不能进行并行操作，也就解决了 ~~*幻读*~~  的问题。



**总结：**

| 隔离级别           | 脏读 | 可重复读 | 幻读 |
| ------------------ | ---- | -------- | ---- |
| READ_UNCOMMITTED   | 允许 | 允许     | 允许 |
| READ_COMMITTED     | 阻止 | 允许     | 允许 |
| **REPETABLE_READ** | 阻止 | 阻止     | 允许 |
| SERIALIZABLE       | 阻止 | 阻止     | 阻止 |



***InnoDB** 的默认事务隔离级别是：**可重复读（REPETABLE_READ）**。