<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">InnoDB 索引</h3>



#### InnoDB特征

* 完全的事务支持
* 基于行存储的行级锁
* 多版本并发控制
* 原子死锁检测
* 原子崩溃恢复



#### InnoDB架构

![InnoDB架构](https://i.loli.net/2019/01/14/5c3c064b9dcee.png)

#### InnoDB 逻辑存储结构

在InnoDB 下，所有的数据都存储在一个 **表空间(tablespace)** 中。表空间又由段（segment）、区（extent）、页（page）、行（row）组成。页在一些文档中有时也称为块（block），1 extent = 64 pages，InnoDB存储引擎的逻辑存储结构大致如图所示。

![InnoDB表结构](https://images2015.cnblogs.com/blog/990532/201701/990532-20170116094754739-1789768872.png)



#### B-tree

定义：

B树（B-TREE）满足如下条件，即可称之为m阶B树：

- 每个结点最多拥有m棵子树；
- 根结点最少拥有2颗子树（存在子树的情况下);
- 除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；
- 所有的叶结点都在同一层上；
- 有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；
- 关键字数量需要满足ceil(m/2)-1 <= n <= m-1；

![B-tree](https://i.loli.net/2019/01/14/5c3c2564e867a.png)

B-tree的特点是每个结点不仅存放键值，而且存放数据。

---

#### B+tree

![B+tree](https://i.loli.net/2019/01/14/5c3c24d11402a.png)



**B+树特点：**

* 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
* 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。



**B+树的优点：**

* 单一节点存储更多的元素（因为不含有对应的值，仅仅含有键），使得查询的IO次数更少。
* 所有查询都要从根节点查找到叶子节点，查询性能稳定，相对于B树更加稳定，以为B+树只有叶子节点存储了对应的值信息。
* 所有叶子节点形成有序双向链表，对于SQL的范围查询以及排序查询都很方便。
* B/B+树的共同优点的每个节点有更多的孩子，插入不需要改变树的高度，从而减少重新平衡的次数，非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入的应用。树中节点存储这指向页的信息，可以快速定位到磁盘对应的页上面。



#### 存储引擎对比

| 引擎       | 存储限制 | 支持事务 | 全文索引 | 哈希索引 | 数据缓存 | 支持外键 |
| ---------- | -------- | :------: | :------: | :------: | :------: | :------: |
| **InnoDB** | 64TB     |    ✅     |   :x:    |    ✅     |    ✅     |    ✅     |
| **MyISAM** | 256TB    |   :x:    |    ✅     |    ✅     |   :x:    |   :x:    |
| Memory     | RAM      |   :x:    |   :x:    |    ✅     |   N/A    |   :x:    |
| Archive    | None     |   :x:    |   :x:    |   :x:    |   :x:    |   :x:    |



参考资料：

[InnoDB 存储引擎原理解析](https://zhuanlan.zhihu.com/p/35925589)

[InnoDB索引最通俗的解释](https://blog.csdn.net/u010710458/article/details/80209909)