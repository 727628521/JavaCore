<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">主从复制</h3>

**数据复制的意义:** 1、读写分离，降低单节点的读写压力；2、容灾转移，单机出现问题，从节点接替。

Redis 数据复制是单向的，而且一个节点只能从属一个master节点。



设置主从复制方式一: redis实例启动前，在配置文件中设置 `slaveof host port`

设置主从复制方式二: redis实例启动时，使用 `redis-server` 加上 `--slaveof host port`

设置主从复制方式三:redis实例启动后，在命令行设置 `slaveof host port`

断开主从复制:在从节点命令行执行 `slaveof no one`



#### 一主一从: 

![一主一从](https://i.loli.net/2019/02/11/5c612b5f58ffc.png)

常规的主从配置，一个主节点配置一个从节点。

作主备容灾转移时，主节点负责读写，从节点负责复制数据，一旦主节点宕机，从节点晋升为主节点，接替读写工作；

做读写分离时，主节点只写，从节点只读。

注意，节点最好要开启持久化，否则Redis实例宕机重启后，数据变空。



#### 一主多从:

![一主多从](https://i.loli.net/2019/02/11/5c612ba97b585.png)

根据“二八原则”，大部分场景下都是在读操作，通常给主节点配置多个从节点，主节点只写，从节点只读，从节点间分摊压力。



#### 树状主从:

![树状主从](https://i.loli.net/2019/02/11/5c612bbf22aea.png)

但是从节点过多，主节点的IO就越大（主要是IO中的O），这时就会出现IO堵塞。使用树状主从结构，每个主节点的从节点数量就变少，这样主节点的IO输出压力就会变小，非叶子节点的主节点层层分担压力，从而降低根节点的压力。

(为了能够校正数据，不推荐将从节点设置为只读模式 ~~slave-read-only=yes~~)



---

<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">复制原理</h3>

![Redis注册复制原理](https://i.loli.net/2019/02/12/5c62226abbf3d.png)

首先，通过上述配置主从复制，从节点保存主节点的信息，然后建立 socket 连接。Redis的ping命令是用于客户端检测服务端是否正常运作或消息延时的一种命令，是一种心跳机制，在这里从节点就是客户端，主节点就是服务端。从节点发送ping命令至主节点，如果主节点正常运作则返回pong，这样才能表示双方网络通达。紧接着，如果主节点开启 `requirepass foobared` 参数（foobared 可以认为是安全校验密码），主节点会对从节点进行权限校验。密码正确后，才进行数据同步，最后不断的、陆陆续续的、持续复制后面的数据，实现这一持续复制数据的实现方式就是复制其操作命令。



---

<h3 style="padding-bottom:6px; padding-left:20px; color:#ffffff; background-color:#E74C3C;">故障转移</h3>

对于单个节点而言，有可能出现故障(fail)，为了保证该服务的可用性，需要使用其他冗余或备用节点来接替该节点工作，这种拯救方式就是 **故障转移(Failover)** 。

比如一个 **一主两从** 的高可用方案，主节点工作，从节点作备用:

![一主两从](https://i.loli.net/2019/02/16/5c67baed29b4a.png)

如果主节点（master节点）出现故障，那么服务不可用，从节点（slave节点）也无法从master节点持续复制数据，如何实现故障转移呢？下面是基于客户端的实现。

1. 客户端使用心跳机制，定时检测 master、slave节点活性，比如使用ping命令;

2. 如果master节点在一定时间内无回复，则认为master节点此时不可用;

3. 从slave节点中随机选择或选择一个ping-pong网络较好的一个节点晋升为master，比如6380节点;

4. 6380节点和6381节点先与6379断开复制关系 `slaveof no one`;

5. 然后以6380为master节点，6381为salve节点建立复制关系;

   ![建立新的主从复制](https://i.loli.net/2019/02/16/5c67c5a831a15.png)

6. 通过心跳检测6379节点故障恢复后，作为salve节点与master节点建立主从复制关系;

   ![屏幕快照 2019-02-16 下午4.10.30.png](https://i.loli.net/2019/02/16/5c67c61676337.png)

7. 故障转移完成。（其实到了第3步选取6380为主节点后，服务就可用了）



客户端为了高可用，也可以做成多节点，在Redis的master节点出现故障时，客户端多节点通过选举方式来产生新的master节点。从Redis 2.8 版本开始，新加入了 Redis Sentinel 来实现高可用。